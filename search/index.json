[{"content":"2023-01-16 2024-01-16 ","date":"2024-01-15T00:00:00Z","permalink":"https://examnple.com/posts/%E5%8E%BB%E5%B9%B4%E4%BB%8A%E5%A4%A9/","title":"去年今天"},{"content":" # 人物对话与图像 首先下载好renpy引擎及其资源如果没有点此链接: ren-py资源 打开引擎后就是这个样子: # 分支头:看的懂英语可以跳过此处 首先点击右下角的preferences 再点击中文(或者任意你喜欢的语言),后期教程以中文界面为主 # 分支尾:看的懂英语可以跳过此处 # 项目的创建 让我们返回到主菜单,点击\u0026quot;创建新项目\u0026quot; 点击\u0026quot;继续\u0026quot; 输入项目名称,我们这里叫:\u0026ldquo;Eutopia RenPy Journey\u0026rdquo;(名称不可以输入不再ASCII内的字符,关于ASCII,有兴趣自行搜索) 点击继续,以及后面两个都保持为默认,点击继续 稍等片刻后我们会返回到主菜单 箭头所指的便是我们新建的项目 让我们启动项目试试看 右下角是我们的游戏名称,左边是我们的游戏菜单(虽然现在很丑,但后面会美化的) 点击开始游戏试试看 点击两次后便会返回游戏主界面 # Tips:接下来需要写代码了,请各位阁下做好心理准备! Ok,相信大家都做好了准备,接下来就是愉快的代码编写时间!\n先回到主界面,看到右上角一个名为script.rpy的脚本文件吗？ 点击它,就可以跳转到\u0026hellip;\u0026hellip;什么?你没跳转?那就跟着下面图片去配置吧!\n# 分支头2,可以跳转的跳过 自行选择一个你喜欢的编辑器吧!\n# 分支尾2,可以跳转的跳过 这是文件中的代码:\n# 游戏的脚本可置于此文件中。 # 声明此游戏使用的角色。颜色参数可使角色姓名着色。 define e = Character(\u0026#34;艾琳\u0026#34;) # 游戏在此开始。 label start: # 显示一个背景。此处默认显示占位图，但您也可以在图片目录添加一个文件 # （命名为 bg room.png 或 bg room.jpg）来显示。 scene bg room # 显示角色立绘。此处使用了占位图，但您也可以在图片目录添加命名为 # eileen happy.png 的文件来将其替换掉。 show eileen happy # 此处显示各行对话。 e \u0026#34;您已创建一个新的 Ren\u0026#39;Py 游戏。\u0026#34; e \u0026#34;当您完善了故事、图片和音乐之后，您就可以向全世界发布了！\u0026#34; # 此处为游戏结尾。 return 看上去复杂吗？其实就光凭这个注释就可以明白大半了 但是,我们还是一步一步来比较好\n# 首先,一个普通的gal需要角色 Q:如何创建一个角色? A:define [随便一个字符串,用来代表你的角色,每个角色需要有一个唯一的字符串!在下文用\u0026quot;e\u0026quot;表示] = Character (\u0026ldquo;你的角色名\u0026rdquo;) Tips:编写代码时需要注意大小写,缩进,以及符号(必须为英文字符!) Q:如何让角色说话? A:e \u0026ldquo;你想让角色说的话\u0026rdquo; Tips:在Ren\u0026rsquo;py中游戏会从\u0026quot;label start:\u0026ldquo;开始,角色说话时注意缩进!最好以空格代替Tab键! Q:我想显示我角色(laopo)的立绘,该怎么写? A:这个有点小麻烦,首先你需要一张图片,把它放在游戏项目的images目录,(名称最好英文全小写,根据机制,文件名在代码编写的时候会强制改为小写并剔除扩展名。譬如我有一张名为Mypic.png的图片,在写代码时需要全小写,也就是\u0026quot;mypic\u0026rdquo;)show [文件名] Q：默认背景好难看，怎么更换背景？ A：同上，只不过需要将show改为scene # 代码实践 #在文本前面加\u0026#34;#\u0026#34;叫做注释，注释不会被引擎运行——所以你可以在这里夹杂私货[笑] #好吧，事实上这个是用来备忘的，一些复杂的项目的代码时间久了你有可能会记不住你写的是什么，这时注释就起到作用了 #创建一个角色Eutopia define t = Character (\u0026#34;Eutopia\u0026#34;) #游戏开始的地方 label start: #这是一个背景,图片名称Utopia,别忘了小写 scene utopia #角色立绘,图片名称Eutopia show eutopia t \u0026#34;基本上就是这样\u0026#34; t \u0026#34;让我们运行看看\u0026#34; #游戏在此结束 return 左代码,右程序 # 图像的基本运用 头像设置 图像的移动与位置 头像设置 这是肥肠简单的一个办法:在image后面加一个side就行了,其余与立绘一样 image side eutopia=\u0026#34;eutopia-h.png\u0026#34; 这里头像资源文件名叫eutopia-h.png,你也可以使用其他的,最好是透明png格式 2. 图像的移动与位置\n# eutopia换装ing\u0026hellip; [renpy默认位置是中间,具体写法请查看前面立绘部分] 这时,如果我们想让她出现在左或者右边该怎么写呢？\nshow eutopia at left #出现在左 show eutopia at right #出现在右 出现在左: 出现在右: # 附页 Tips:文件夹结构图 images:存放图片 gui:存放游戏界面资源 audio:存放音频文件 tl:翻译文件 saves:游戏存档文件 cache:缓存文件\n","date":"2024-01-11T00:00:00Z","permalink":"https://examnple.com/posts/gal/","title":"Gal从ZERO到HERO的Renpy开发教程"},{"content":"从前有一只鸽子前来咕咕: 咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕咕\n","date":"2024-01-10T00:00:00Z","permalink":"https://examnple.com/posts/gugu/","title":"喵帕斯~"},{"content":" # 首先,感谢一下linuxgame.cn提供的标准化打包工具 # 再感谢一下shinnku.com的Gal (笑) 请让我把工具准备好: 一个Linux发行版(WSL也可以),我选用的是KaliLinux Appimagetool(Github上有)\n以及来自linuxgame网站的打包工具 链接{自带旧版本appimagetool以及wine依赖,但我们不需要}\n记得下好游戏并成功运行在本机wine环境上\n以及打包的灵魂:wine (可从archlinux包仓库或者debian包仓库获得) 这里我们演示的是\u0026hellip;\u0026hellip; GINKA ! 成品演示: # 在开始之前,我觉得我得解释一下,Wine是什么 Wine （“Wine Is Not an Emulator” 的首字母缩写）是一个能够在多种 POSIX-compliant 操作系统（诸如 Linux，macOS 及 BSD 等）上运行 Windows 应用的兼容层。Wine 不是像虚拟机或者模拟器一样模仿内部的 Windows 逻辑，而是將 Windows API 调用翻译成为动态的 POSIX 调用，免除了性能和其他一些行为的内存占用，让你能够干净地集合 Windows 应用到你的桌面。\nWine 项目由 Bob Amstadt 于 1993 年发起，旨在寻求一种在 Linux 上运行 Windows 3.1 程序的办法。不久之后，Alexandre Julliard 开始接手领导 Wine 的开发，从此由他管理这个项目。 多年以来，随着 Windows API 和应用为了适应新硬件及软件而不断演变，Wine 也一直不断发展来支持新的特性，移植到更多其他系统，并且更加稳定，提供着更好的用户体验。\n通过确立一个宏伟的目标，在 2008 年项目到达 v1.0 之前，Wine 一直稳健地持续了 15 年之久，那是第一个稳定版。 多个版本以后，虽然还有许多工作要做，但今天 Wine 仍然在活跃地开发着。 并且有大约数以百万人计的人们使用 Wine 在他们所选择的系统上运行 Windows 软件。 开放源代码和用户驱动的\nWine 将会永远是自由软件。 大约一半的 Wine 代码由志愿者编写，其余部分由商业公司赞助。特别是 CodeWeavers，出售着一个 Wine 的支持版本。\nWine 也是高度依赖用户社区的。用户自愿贡献时间在我们的 Application Database 上分享技巧和他们程序的运行测试结果，在我们的 Bug-Tracker 上撰写 bug 报告提醒开发者问题所在，或者在论坛上回复问题。 (来自wine官网 链接) (注:无论是最近苹果的游戏打包工具还是安卓的win模拟器,本质上都是wine哦~)\n# 关于APPIMAGE 简单.\nAppImage的核心思想是一个应用程序 = 一个文件 。每个AppImage都包含应用程序以及应用程序运行所需的所有文件。换句话说，除了操作系统本身的基础组件，Appimage不需要依赖包即可运行。\n可靠.\nAppImage 格式是上游应用打包的理想选择，这意味着你可以直接从开发者那里获取软件，而不需要任何中间步骤，这完全符合开发者意图。非常迅速。\n快速.\nAppImage应用可以直接下载并且运行，无需安装，并且不需要root权限。 (来自appimage官网链接)\n# 打包流程 事实上没什么可以讲的,请看图: 这个是软件入口,gamux将它指向了文件\u0026quot;$(pwd)/usr/bin/games\u0026quot;(好像还有一种是指向.desktop桌面文件的)\n# 我们再来看看脚本内容 首先是config,这是一个配置文件\n#!/bin/bash ###设置，根据需要修改### #游戏名称,可以随意起，请务必使用英文，游戏名切勿包含空格及其他符号 GAMUX_GAME_NAME=\u0026#34;GINKA\u0026#34; #游戏所在文件夹的名称，默认为game GAMUX_GAME_BIN_DIR=\u0026#34;game\u0026#34; #game文件夹中游戏执行文件 GAMUX_GAME_EXEC=\u0026#34;run\u0026#34; #是否启用steam-runtime，0为不启用，1为启用。若不启用，可以删除当前目录的steam-runtime节省游戏体积 #非x86游戏不支持steam-runtime GAMUX_STEAMRUNTIME=0 #x86平台只支持在64位系统运行，不论游戏是32或64位 #arm平台只支持在arm64系统运行，不论armel、armhf或arm64的游戏 PLATFORM=amd64 ###定义变量部分，无需修改### HERE=$(cd \u0026#34;$(dirname \u0026#34;$0\u0026#34;)\u0026#34;;pwd) cd \u0026#34;${HERE}\u0026#34; GAMUX_GAME_READONLY=\u0026#34;${HERE}/${GAMUX_GAME_BIN_DIR}\u0026#34; GAMUX_GAME_DIR=\u0026#34;${HOME}/.local/share/gamux/${GAMUX_GAME_NAME}\u0026#34; GAMUX_GAME_DATA=\u0026#34;${GAMUX_GAME_DIR}/data\u0026#34; GAMUX_GAME_DATA_TMP=\u0026#34;${GAMUX_GAME_DIR}/${GAMUX_GAME_NAME}_gamux_mountdir\u0026#34; ###自定义部分，补充默认脚本的不足### function gamux_function1() { # if [ ! -d \u0026#34;${GAMUX_GAME_READONLY}/characters\u0026#34; ];then # tar zxvf \u0026#34;${HERE}/characters.tar.gz\u0026#34; -C \u0026#34;${GAMUX_GAME_DATA_TMP}\u0026#34; # fi return 10086 } 大佬写的注释挺详细的哈,我们应该向ta学习[笑] 基本上就是定义了游戏名称\u0026quot;GINKA\u0026quot;,游戏所在文件夹\u0026quot;game\u0026quot;,以及\u0026quot;game\u0026quot;文件夹中的可执行文件\u0026quot;run\u0026quot;,其余的对于我们打包而言,意义不大(但是没有shell基础不要乱改哈)\n我们再来看看games\n#!/bin/bash source \u0026#34;$(cd \u0026#34;$(dirname \u0026#34;$0\u0026#34;)\u0026#34;;pwd)/config\u0026#34; \u0026#34;${HERE}\u0026#34;/game_run fusermount -u -z \u0026#34;${GAMUX_GAME_DATA_TMP}\u0026#34; rmdir \u0026#34;${GAMUX_GAME_DATA_TMP}\u0026#34; 我们先来看看第一行#!/bin/bash 这是设定一个解释器,这里是bash,你也可以设置为dash,sh,zsh等 往下看,这是一个经典的当前路径获取代码,获取当前脚本文件的父目录，注意 $0 为脚本执行时传入的脚本路径名,翻译过来就是:打开并运行当前脚本文件父目录下的config脚本,这是配置了环境变量 (关于${HERE},请查看config文件的 ###定义变量部分，无需修改### 部分) 下面两行是挂载与垃圾清理,不重要(其实就是懒,毕竟已经23:01了)\ngame_run文件,看名字就知道是干什么的了吧\u0026hellip;\u0026hellip;\n#!/bin/bash # figure out the absolute path to the script being run a bit # non-obvious, the ${0%/*} pulls the path out of $0, cd\u0026#39;s into the # specified directory, then uses $PWD to figure out where that # directory lives - and all this in a subshell, so we don\u0026#39;t affect # $PWD source \u0026#34;$(cd \u0026#34;$(dirname \u0026#34;$0\u0026#34;)\u0026#34;;pwd)/config\u0026#34; if [ ! -d \u0026#34;${GAMUX_GAME_DATA}\u0026#34; ];then mkdir -p \u0026#34;${GAMUX_GAME_DATA}\u0026#34; fi if [ ! -d \u0026#34;${GAMUX_GAME_DATA_TMP}\u0026#34; ];then mkdir \u0026#34;${GAMUX_GAME_DATA_TMP}\u0026#34; fi UNIONFS=\u0026#34;unionfs_${PLATFORM}\u0026#34; \u0026#34;${HERE}\u0026#34;/${UNIONFS} -o big_writes,umask=0002,direct_io,auto_cache,sync_read,nonempty,uid=$(id -u),gid=$(id -g),cow \u0026#34;${GAMUX_GAME_DATA}\u0026#34;=RW:\u0026#34;${GAMUX_GAME_READONLY}\u0026#34;=RO ${GAMUX_GAME_DATA_TMP} #自定义代码 gamux_function1 ############################################################################################### #启动游戏 cd \u0026#34;${GAMUX_GAME_DATA_TMP}\u0026#34; if [ ${GAMUX_STEAMRUNTIME} -eq 0 ];then \u0026#34;${GAMUX_GAME_DATA_TMP}/${GAMUX_GAME_EXEC}\u0026#34; \u0026#34;$@\u0026#34; else \u0026#34;${HERE}/steam-runtime/run.sh\u0026#34; \u0026#34;${GAMUX_GAME_DATA_TMP}/${GAMUX_GAME_EXEC}\u0026#34; \u0026#34;$@\u0026#34; fi 接下来就是我自己写的脚本了,位于game文件夹中的run脚本,\n#!/bin/sh export WINEHOME=$(pwd) export WINEPREFIX=$(pwd)/C #export WINEARCH=none export WINE=./bin/wine $WINE game/run.exe export WINEDLLPATH=$(pwd)/lib/wine/i386-windows/:$(pwd)/lib/wine/x86_64-windows/ 非常简单的几句代码,分别设定了wine主目录的环境变量,wine c盘的环境变量,wine的架构(没有设定,为none),以及wine的可执行程序 $WINE game/run.exe (用wine运行game目录下的run.exe) # 打包 打包之前要注意以下几点: 1.在此之前先运行一下games文件,检查game/C 文件夹是否有以下文件,没有就失败了(可以运行,但喜提 -1GB空间,你可以理解为这是优化) 2.一个game.png文件推荐256x256(不是也行) 3.编辑desktop 附赠desktop文件内容(以免损坏)\n[Desktop Entry] Name=GINKA Exec=games Icon=game Type=Application Categories=Game; Comment= Path= Terminal=false StartupNotify=false # 开始打包 准备好appimagetool.appimage,在此打开终端,输入\nARCH=x86_64 ./appimagetool-x86_64.AppImage squashfs-root GINKA.Appimage 解释: [ARCH=架构] [运行appimagetool] [参数1:所要打包的文件夹] [参数2:打包成什么]\n出现以下场景就成功了 作者的小声哔哔:写这个时候才21:20左右,现在是23:34了,现在脑子一团糟,文章后期也开始偷懒,有什么纰漏请见谅\n","date":"2024-01-07T00:00:00Z","permalink":"https://examnple.com/posts/linux/","title":"Linux打包流程 For wine Appimage"},{"content":"测试文档\u0026hellip;\u0026hellip;\n","date":"2023-12-31T00:00:00Z","permalink":"https://examnple.com/posts/%E6%B5%8B%E8%AF%95/","title":"测试"}]